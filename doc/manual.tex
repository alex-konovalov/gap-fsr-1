% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}



\usepackage[pdftex]{graphicx}

%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{FSR}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{FSR}}
\markright{\scriptsize \mbox{}\hfill \textsf{FSR} \hfill\mbox{}}
{\Huge \textbf{...\mbox{}}}\\
\vfill

{\Huge Version 1.1.0\mbox{}}\\[1cm]
{22 March 2017\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Nusa Zidaric   \mbox{}}}\\
{\Large \textbf{Mark Aagaard   \mbox{}}}\\
{\Large \textbf{Guang Gong   \mbox{}}}\\
\hypersetup{pdfauthor=Nusa Zidaric   ; Mark Aagaard   ; Guang Gong   }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Nusa Zidaric   }  Email: \href{mailto://nzidaric@uwaterloo.ca} {\texttt{nzidaric@uwaterloo.ca}}\\
  Homepage: \href{http://} {\texttt{http://}}}\\
{\mbox{}\\
\small \noindent \textbf{Mark Aagaard   }  Email: \href{mailto://maagaard@uwaterloo.ca} {\texttt{maagaard@uwaterloo.ca}}\\
  Homepage: \href{http://} {\texttt{http://}}}\\
{\mbox{}\\
\small \noindent \textbf{Guang Gong   }  Email: \href{mailto://ggong@uwaterloo.ca} {\texttt{ggong@uwaterloo.ca}}\\
  Homepage: \href{http://} {\texttt{http://}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 \index{FSR package@\textsf{FSR} package} The \textsf{GAP} package \textsf{FSR} ... \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 {\copyright} 2017-2017 by Nusa Zidaric, Mark Aagaard, Guang Gong

 \textsf{FSR} is free software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version. For
details, see the FSF's own site \href{http://www.gnu.org/licenses/gpl.html} {\texttt{http://www.gnu.org/licenses/gpl.html}}. 

 If you obtained \textsf{FSR}, we would be grateful for a short notification sent to one of the authors. 

 If you publish a result which was partially obtained with the usage of \textsf{FSR}, please cite it in the following form: 

 N. Zidaric. ... \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 ... \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Preface}}\label{Preface}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X874E1D45845007FE}{}
{
  The \textsf{GAP} package \textsf{FSR} implements Feedback Shift Registers }

 
\chapter{\textcolor{Chapter }{FSR (Feedback Shift Register)}}\label{FSR}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7D2B014884E6D3D8}{}
{
  
\section{\textcolor{Chapter }{Common functionality}}\label{fsrcommon}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7D5E0FF97CA51E2E}{}
{
  \index{fsr} We define an object \textsf{FSR} (Feedback Shift Register), which can come in two flavours: with linear
feedback \texttt{LFSR} (\ref{LFSR}) and nonlinear feedback \texttt{NLFSR} (\ref{NLFSR}). Because of many similarities between the two, the basic common functionality
can be found here, while specialized functions (such as \texttt{LFSR} and \texttt{NLFSR} object creation) in corresponding sections. 

\subsection{\textcolor{Chapter }{IsFSR}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X867B95117FAEC3E6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFSR\index{IsFSR@\texttt{IsFSR}}
\label{IsFSR}
}\hfill{\scriptsize (filter)}}\\


 This is the category of \texttt{FSR} objects. Objects in this category are created using functions \texttt{LFSR} (\ref{LFSR}) or \texttt{NLFSR} (\ref{NLFSR}). }

 

\subsection{\textcolor{Chapter }{FieldPoly}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X828F246B82428CC9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FieldPoly({\mdseries\slshape fsr})\index{FieldPoly@\texttt{FieldPoly}}
\label{FieldPoly}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingField({\mdseries\slshape fsr})\index{UnderlyingField@\texttt{UnderlyingField}}
\label{UnderlyingField}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FeedbackVec({\mdseries\slshape fsr})\index{FeedbackVec@\texttt{FeedbackVec}}
\label{FeedbackVec}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OutputTap({\mdseries\slshape fsr})\index{OutputTap@\texttt{OutputTap}}
\label{OutputTap}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{FieldPoly} of the \mbox{\texttt{\mdseries\slshape fsr}} stores the irreducible polynomial used to construct the extension field or 1
in case of a prime field.

 \texttt{UnderlyingField} of the \mbox{\texttt{\mdseries\slshape fsr}} is the finite field over which the \mbox{\texttt{\mdseries\slshape fsr}} is defined (all indeterminates and constants are from this field). 

 NOTE: it may seem redundant to sore both \texttt{FieldPoly} and \texttt{UnderlyingField}, however, they are used by other functions in the package. 

 \texttt{FeedbackVec} of the \mbox{\texttt{\mdseries\slshape fsr}} stores the coefficients of the \texttt{CharPoly} without its leading term in case of \texttt{LFSR}, and coefficients of the nonzero monomials present in the multivariate
function defining the feedback in case of \texttt{NLFSR}.

 \texttt{OutputTap} holds the output tap position(s): the sequence elements are taken from the
stage(s) listed in \texttt{OutputTap}. }

 

\subsection{\textcolor{Chapter }{Length}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X780769238600AFD1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Length({\mdseries\slshape fsr})\index{Length@\texttt{Length}}
\label{Length}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InternalStateSize({\mdseries\slshape fsr})\index{InternalStateSize@\texttt{InternalStateSize}}
\label{InternalStateSize}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Threshold({\mdseries\slshape fsr})\index{Threshold@\texttt{Threshold}}
\label{Threshold}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{Length} of the \mbox{\texttt{\mdseries\slshape fsr}} is the number of its stages.

 \texttt{InternalStateSize} of the \mbox{\texttt{\mdseries\slshape fsr}} is size in bits needed to store the state $length \cdot width$, where $ width = DegreeOverPrimeField(UnderlyingField(\mbox{\texttt{\mdseries\slshape fsr}}))$. 

 \texttt{Threshold} of the \mbox{\texttt{\mdseries\slshape fsr}} is currently set to $Characteristic(\mbox{\texttt{\mdseries\slshape fsr}})^t+\ell$, where $t=InternalStateSize(\mbox{\texttt{\mdseries\slshape fsr}})$ and $\ell=Length(\mbox{\texttt{\mdseries\slshape fsr}})$.

 }

 

\subsection{\textcolor{Chapter }{ChangeBasis}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X865130F47A6843E5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ChangeBasis({\mdseries\slshape fsr, B})\index{ChangeBasis@\texttt{ChangeBasis}}
\label{ChangeBasis}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WhichBasis({\mdseries\slshape fsr})\index{WhichBasis@\texttt{WhichBasis}}
\label{WhichBasis}
}\hfill{\scriptsize (method)}}\\


 \texttt{ChangeBasis} allows changing the basis of the \mbox{\texttt{\mdseries\slshape fsr}} to basis \mbox{\texttt{\mdseries\slshape B}}. Basis B must be given for \texttt{UnderlyingField(fsr)} over its prime subfield. 

 \texttt{WhichBasis} returns the basis currently set for the \mbox{\texttt{\mdseries\slshape fsr}}. Elements in the \mbox{\texttt{\mdseries\slshape fsr}} state are still represented in GAP native representation, but the functions
with basis switch turned on will print the elements w.r.t to currently set
basis. }

 

\subsection{\textcolor{Chapter }{LoadFSR}}
\logpage{[ 2, 1, 5 ]}\nobreak
\hyperdef{L}{X7F800DCF810E2532}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LoadFSR({\mdseries\slshape fsr, ist})\index{LoadFSR@\texttt{LoadFSR}}
\label{LoadFSR}
}\hfill{\scriptsize (method)}}\\


 Loading the \mbox{\texttt{\mdseries\slshape fsr}} with the initial state \mbox{\texttt{\mdseries\slshape ist}}, which is a \mbox{\texttt{\mdseries\slshape FFE}} vector of same length as \mbox{\texttt{\mdseries\slshape fsr}} and with elements from its underlying finite field. If either of those two
requirements is violated, loading fails and error message appears. At the time
of loading the initial sequence elements (ie zeroth elements) are obtained and \texttt{numsteps} is set to 0. 

 }

 

\subsection{\textcolor{Chapter }{StepFSR}}
\logpage{[ 2, 1, 6 ]}\nobreak
\hyperdef{L}{X82A7CA487ECAEFD5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StepFSR({\mdseries\slshape fsr[, elm]})\index{StepFSR@\texttt{StepFSR}}
\label{StepFSR}
}\hfill{\scriptsize (method)}}\\


 Perform one step the \mbox{\texttt{\mdseries\slshape fsr}}, ie. compute the new \texttt{state} and update the \texttt{numsteps}, then output the elements denoted by \texttt{OutputTap}. If the optional parameter \mbox{\texttt{\mdseries\slshape elm}} is used then the new element is computed as a sum of computed feedback and \mbox{\texttt{\mdseries\slshape elm}}. Elemen \mbox{\texttt{\mdseries\slshape elm}} must be an element of the underlying finite field. 

 As this is a way to destroy the linearity of an \texttt{LFSR}, we refer to \texttt{StepFSR} with the optiomal nonzero \mbox{\texttt{\mdseries\slshape elm}} as \texttt{nonlinear step}. Similarly, the \texttt{NLFSR} can also have an extra element added to the (already nonlinear) feedback.

 Returns an error if the \mbox{\texttt{\mdseries\slshape fsr}} is not loaded!

 }

 

\subsection{\textcolor{Chapter }{RunFSR}}
\logpage{[ 2, 1, 7 ]}\nobreak
\hyperdef{L}{X86AAB63D8781648A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RunFSR({\mdseries\slshape fsr[, ist, num, pr]})\index{RunFSR@\texttt{RunFSR}}
\label{RunFSR}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RunFSR({\mdseries\slshape fsr, elm[, num, pr]})\index{RunFSR@\texttt{RunFSR}}
\label{RunFSR}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RunFSR({\mdseries\slshape fsr, ist, elmvec[, pr]})\index{RunFSR@\texttt{RunFSR}}
\label{RunFSR}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RunFSR({\mdseries\slshape fsr, z, elmvec[, pr]})\index{RunFSR@\texttt{RunFSR}}
\label{RunFSR}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 A sequence of elements generated by \texttt{FSR}. 



 The \mbox{\texttt{\mdseries\slshape fsr}} will be run for $min(\mbox{\texttt{\mdseries\slshape num}} , Threshold(\mbox{\texttt{\mdseries\slshape fsr}}))$ number of steps: value Threshold(\mbox{\texttt{\mdseries\slshape fsr}}) is used by all versions without explicit \mbox{\texttt{\mdseries\slshape num}} and enforced when \mbox{\texttt{\mdseries\slshape num}} exceeds Threshold(\mbox{\texttt{\mdseries\slshape fsr}}). There is an optional printing switch \mbox{\texttt{\mdseries\slshape pr}}, with default set to \emph{false}; if \emph{true} then the state and the output sequence element(s) are printed in \textsf{GAP} shell on every step of the \mbox{\texttt{\mdseries\slshape fsr}} (we call this output for \texttt{RunFSR}), and the currently set basis \mbox{\texttt{\mdseries\slshape B}} is used for representation of elements. 
\begin{itemize}
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr[, num, pr] }})} - run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num}}/\mbox{\texttt{\mdseries\slshape threshold}} steps with/without output
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, ist[, num, pr] }})} - load \mbox{\texttt{\mdseries\slshape fsr}} with \mbox{\texttt{\mdseries\slshape ist}}, then run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num}}/\mbox{\texttt{\mdseries\slshape threshold}} steps with/without output (ie. \emph{linear} version)
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, elm[, num, pr] }})} - run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num}}/\mbox{\texttt{\mdseries\slshape threshold}} steps, whereby the SAME element \mbox{\texttt{\mdseries\slshape elm}} is added to the feedback at each step, with/without output (ie. \emph{non-linear} version)
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, ist, elmvec[, pr] }})} - load \mbox{\texttt{\mdseries\slshape fsr}} with \mbox{\texttt{\mdseries\slshape ist}}, then run \mbox{\texttt{\mdseries\slshape fsr}} for \emph{Length(\mbox{\texttt{\mdseries\slshape elmvec}})} steps, whereby one element of \mbox{\texttt{\mdseries\slshape elmvec}} is added to the feedback at each step (starting with \mbox{\texttt{\mdseries\slshape elmvec[1]}}), with/without output (ie. \emph{non-linear} version). NOTE: the sequence returned has length \emph{Length(elmvec)+1}, because the zeroth sequence element is returned at the time of loading the \texttt{FSR}.
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, z, elmvec[, pr] }})} - input \mbox{\texttt{\mdseries\slshape z}} must be set to 0 to indicate we want to continue a run with new \mbox{\texttt{\mdseries\slshape elmvec}}: run \mbox{\texttt{\mdseries\slshape fsr}} for \emph{Length(\mbox{\texttt{\mdseries\slshape elmvec}})} steps, whereby one element of \mbox{\texttt{\mdseries\slshape elmvec}} is added to the feedback at each step (starting with \mbox{\texttt{\mdseries\slshape elmvec[1]}}), with/without output (ie. \emph{non-linear} version). NOTE: the sequence returned has length \emph{Length(elmvec)}.
\end{itemize}
 For the load and run versions, element seq$_0$ is a part of the output sequence, hence the output sequence has the length \mbox{\texttt{\mdseries\slshape num+1}}/\mbox{\texttt{\mdseries\slshape threshold+1}}/\mbox{\texttt{\mdseries\slshape Length(elmvec)+1}}. 

 For versions without the loading of \mbox{\texttt{\mdseries\slshape ist}}, calling \texttt{RunFSR} returns an error if the \mbox{\texttt{\mdseries\slshape fsr}} is not loaded!

 The ouput of \texttt{RunFSR} is: 
\begin{itemize}
\item  sequence of \mbox{\texttt{\mdseries\slshape FFE}}s : seq$_0$, seq$_1$, seq$_2$, $\dots ,$ for \emph{Length}(\emph{OutputTap})=1
\item  sequence of vectors, each of them with $t$ \mbox{\texttt{\mdseries\slshape FFE}}s : seq$_0$, seq$_1$, seq$_2$, $\dots ,$ where seq$_i=($ seq$_{i1}$, $\dots , $ seq$_{it}$) for \emph{Length}(\emph{OutputTap})=t
\end{itemize}
 Example of \texttt{RunFSR} called for an lfsr \emph{test} over $F_{2^4}$, with initial state \emph{ist}, print switch \emph{true} for basis \emph{B}, with run length 5: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@K := GF(2);; x := X(K, "x");;|
  !gapprompt@gap>| !gapinput@f := x^4 + x^3 + 1;; F := FieldExtension(K, f);; B := Basis(F);;|
  !gapprompt@gap>| !gapinput@y := X(F, "y");; l := y^4+ y+ Z(2^4);;|
  !gapprompt@gap>| !gapinput@test := LFSR(K, f, l);;|
  < empty LFSR given by CharPoly = y^4+y+Z(2^4)>
  !gapprompt@gap>| !gapinput@ist :=[0*Z(2), Z(2^4), Z(2^4)^5, Z(2)^0 ];;|
  !gapprompt@gap>| !gapinput@RunFSR(test, ist, 5, true);             |
  using basis B := [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]	
  elm			[ 3,	...	...,0 ]  with taps  [ 0 ]
    [ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ], [ 1, 0, 0, 0 ] ]
  							[ 1, 0, 0, 0 ]
  	[ [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ] ]
  							[ 1, 1, 0, 1 ]
  	[ [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ] ]
  							[ 0, 1, 1, 0 ]
  	[ [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ] ]
  							[ 0, 0, 0, 0 ]
  	[ [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ] ]
  							[ 1, 0, 1, 1 ]
  	[ [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ] ]
  							[ 0, 1, 1, 1 ]
  [ Z(2)^0, Z(2^2), Z(2^4), 0*Z(2), Z(2^4)^2, Z(2^4)^11 ]
  
\end{Verbatim}
 Example of \texttt{RunFSR} called for an lfsr \emph{test} over $F_{2^4}$, with initial state \emph{ist}, print switch \emph{true} for basis \emph{B}, with 5 nonlinear inputs : 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@elmvec := [Z(2^4)^2, Z(2^4)^2, Z(2^2), Z(2^4)^7, Z(2^4)^6];;                                |
  !gapprompt@gap>| !gapinput@RunFSR(test, ist, elmvec, true);                         |
  using basis B := [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]	
  elm		[ 3,	...	...,0 ]  with taps  [ 0 ]
  [ 0, 0, 0, 0 ]		[ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ],
   [ 1, 0, 0, 0 ] ]		[ 1, 0, 0, 0 ]
  [ 1, 0, 1, 1 ]		[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ],
   [ 1, 1, 0, 1 ] ]		[ 1, 1, 0, 1 ]
  [ 1, 0, 1, 1 ]		[ [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],
   [ 0, 1, 1, 0 ] ]		[ 0, 1, 1, 0 ]
  [ 1, 1, 0, 1 ]		[ [ 0, 1, 1, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ],
   [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
  [ 0, 1, 0, 0 ]		[ [ 0, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 0 ],
   [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
  [ 0, 0, 0, 1 ]		[ [ 1, 1, 0, 1 ], [ 0, 1, 0, 0 ], [ 0, 1, 1, 0 ],
   [ 1, 1, 0, 0 ] ]		[ 1, 1, 0, 0 ]
  [ Z(2^4)^9, Z(2^2), Z(2^4), 0*Z(2), 0*Z(2), Z(2^4)^9 ]
  
\end{Verbatim}
 In both examples above the there is a column \emph{elm}, which is in first case empty, because we are not adding nonlinear inputs to
the feedback, while in the second example, this column shows the element being
added at each step (empty in first row - the loading step). Also note that the
two examples above use the call \texttt{LoadFSR}, which adds the elm seq${{_0}}$ to the sequence, so both sequences above are of length \mbox{\texttt{\mdseries\slshape num+1}}/\mbox{\texttt{\mdseries\slshape Length(elmvec)+1}}, ie 6. The last row in both examples is the actual sequence obtained from
this run, and is kept in Zechs logarithm representation. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@RunFSR(test,  ist); Length(last);|
  [ Z(2)^0, Z(2^2), Z(2^4), 0*Z(2), Z(2^4)^2, Z(2^4)^11, Z(2^4)^2, Z(2^4)^2,
   Z(2^2), Z(2^4)^7, Z(2^4)^6, Z(2^4)^11, Z(2^2)^2, Z(2^4)^14, Z(2^4)^8,
    Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4), Z(2^4)^2, Z(2^4)^9 ]
  21
  
\end{Verbatim}
 Last example above shows a sequence of length 21, ie \mbox{\texttt{\mdseries\slshape threshold+1}}, getting first sequence element from LoadFSR followed by \mbox{\texttt{\mdseries\slshape threshold}} iterations of StepFSR. }

 }

 
\section{\textcolor{Chapter }{LFSR specific funcionality}}\label{lfsr}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7A98C0FE855337A7}{}
{
  

\subsection{\textcolor{Chapter }{LFSR}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X8099A9DC86E0B078}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape F, charpol[, B, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape K, fieldpol, charpol[, B, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape F, charpol[, B, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape p, m, n[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 An empty \texttt{LFSR} with components \texttt{init}, \texttt{state} , \texttt{numsteps} and \texttt{basis} 



 Different ways to create an \texttt{LFSR} oblject, main difference is in creation of the underlying finite field. 

 Inputs: 
\begin{itemize}
\item  \mbox{\texttt{\mdseries\slshape F}} - the underlying finite field (either an extension field or a prime field)
\item  \mbox{\texttt{\mdseries\slshape B}} - basis of F over its prime subfield
\item  \mbox{\texttt{\mdseries\slshape charpol}} - \texttt{LFSR} dfining polynomial 
\item  \mbox{\texttt{\mdseries\slshape fieldpol}} - defifning polynomial of the extension field (must be irreducible)
\item  \mbox{\texttt{\mdseries\slshape p}} - characteeristic 
\item  \mbox{\texttt{\mdseries\slshape m}} - degree of extension (degree of \mbox{\texttt{\mdseries\slshape fieldpol}}) 
\item  \mbox{\texttt{\mdseries\slshape n}} - length of \texttt{LFSR} (degree of \mbox{\texttt{\mdseries\slshape charpoly}})
\item  \mbox{\texttt{\mdseries\slshape tap}} - optional parameter: the output tap (must be a positive integer or a list of
positive integers) and will be changed to the default S{\textunderscore}0 if
the specified integer is out of \texttt{LFSR} range.
\end{itemize}
 Compoents: 
\begin{itemize}
\item  \texttt{init} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the initial state of the \texttt{LFSR}, with indeces from n-1, ..., 0
\item  \texttt{state} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the current state of the \texttt{LFSR}, with indeces from n-1, ..., 0
\item  \texttt{numsteps} - the number of steps performed thus far (initialized to -1 when created, set
to 0 when loaded using \texttt{LoadFSR} (\ref{LoadFSR}) and incremented by 1 with each step (using \texttt{StepFSR} (\ref{StepFSR}))) 
\item  \texttt{basis} - basis of F over its prime subfield (if no basis is given this field is set
to canonical basis of F over its prime subfield) 
\end{itemize}
 Attributes \texttt{FieldPoly} (\ref{FieldPoly}), \texttt{UnderlyingFied} (\ref{UnderlyingFied}), \texttt{CharPoly}, \texttt{FeedbackVec} (\ref{FeedbackVec}), \texttt{Length} (\ref{Length}) and \texttt{OutputTap} (\ref{OutputTap}) and the property \texttt{IsLinearFeedback} are set during the construction of an\texttt{LFSR}. 

 If there is something wrong with the arguments (e.g. attempting to create an
extension field using a reducible poynomial), an error message appears and the
function returns \texttt{fail}.

 Example below shows how to create an empty \texttt{LFSR} over $F_{2^4}$ created as extension of $F_2$, called \emph{test}, firstly without a specified basis, and then with basis \mbox{\texttt{\mdseries\slshape B}}: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@K := GF(2);; x := X(K, "x");;|
  !gapprompt@gap>| !gapinput@f := x^4 + x^3 + 1;; F := FieldExtension(K, f);; |
  !gapprompt@gap>| !gapinput@y := X(F, "y");; l := y^4+ y+ Z(2^4);;|
  !gapprompt@gap>| !gapinput@test := LFSR(K, f, l);|
  < empty LFSR given by CharPoly = y^4+y+Z(2^4)>
  !gapprompt@gap>| !gapinput@WhichBasis(test);|
  CanonicalBasis( GF(2^4) )
  !gapprompt@gap>| !gapinput@B := Basis(F, Conjugates(Z(2^4)^3));;  |
  !gapprompt@gap>| !gapinput@test := LFSR(K, f, l, B);|
  < empty LFSR given by CharPoly = y^4+y+Z(2^4)>
  !gapprompt@gap>| !gapinput@WhichBasis(test);        |
  Basis( GF(2^4), [ Z(2^4)^3, Z(2^4)^6, Z(2^4)^12, Z(2^4)^9 ] )
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsLinearFeedback}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X80DF9A3D7B1E3E92}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLinearFeedback({\mdseries\slshape lfsr})\index{IsLinearFeedback@\texttt{IsLinearFeedback}}
\label{IsLinearFeedback}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLFSR({\mdseries\slshape lfsr})\index{IsLFSR@\texttt{IsLFSR}}
\label{IsLFSR}
}\hfill{\scriptsize (filter)}}\\


 If we were to represent the \mbox{\texttt{\mdseries\slshape lsfr}} with a multivariate polynomial, DegreeOfPolynomial would return 1 - the
feedback polynomial is linear and \texttt{IsLinearFeedback} is set to \emph{true}. (ie. only linear terms are present: monomials with only one variable )

 Filter \texttt{IsLFSR} is defined as and-filter of \texttt{IsFSR} and \texttt{IsLinearFeedback}. }

 

\subsection{\textcolor{Chapter }{CharPoly}}
\logpage{[ 2, 2, 3 ]}\nobreak
\hyperdef{L}{X7D4D9DCC7B4BE3ED}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CharPoly({\mdseries\slshape lfsr})\index{CharPoly@\texttt{CharPoly}}
\label{CharPoly}
}\hfill{\scriptsize (attribute)}}\\


 Attribute holding the characteristic polynomial (the feedback polynomial). }

 

\subsection{\textcolor{Chapter }{IsPeriodic}}
\logpage{[ 2, 2, 4 ]}\nobreak
\hyperdef{L}{X81AC5D2D832C346A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPeriodic({\mdseries\slshape lfsr})\index{IsPeriodic@\texttt{IsPeriodic}}
\label{IsPeriodic}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsUltPeriodic({\mdseries\slshape lfsr})\index{IsUltPeriodic@\texttt{IsUltPeriodic}}
\label{IsUltPeriodic}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsMaxSeqLFSR({\mdseries\slshape lfsr})\index{IsMaxSeqLFSR@\texttt{IsMaxSeqLFSR}}
\label{IsMaxSeqLFSR}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Period({\mdseries\slshape lfsr})\index{Period@\texttt{Period}}
\label{Period}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PeriodIrreducible({\mdseries\slshape lfsr})\index{PeriodIrreducible@\texttt{PeriodIrreducible}}
\label{PeriodIrreducible}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PeriodReducible({\mdseries\slshape lfsr})\index{PeriodReducible@\texttt{PeriodReducible}}
\label{PeriodReducible}
}\hfill{\scriptsize (method)}}\\


 Properties, attributes and methods concerning the periodicity of the output
sequence(s), generated by the \mbox{\texttt{\mdseries\slshape lsfr}}. 

 Properties: 
\begin{itemize}
\item  \texttt{IsPeriodic}: true if constant term of \texttt{CharPoly} != 0 (8.11 lidl, niederreiter) 
\item  \texttt{IsUltPeriodic}: true if \texttt{IsLFSR} is true (8.7 lidl, niederreiter) 
\item  \texttt{IsMaxSeqLFSR}: true if \texttt{CharPoly} is primitive (ref???) 
\end{itemize}
 Attributes: 
\begin{itemize}
\item  \texttt{Period}: holds the period of the UNKNOWNEntity(LFSR) 
\end{itemize}
 Methods to compute the period: 
\begin{itemize}
\item  \texttt{PeriodIrreducible}: 
\item  \texttt{PeriodReducible}: 
\end{itemize}
 }

 }

 
\section{\textcolor{Chapter }{NLFSR specific funcionality}}\label{nlfsr}
\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X797E9B3381339AB2}{}
{
  

\subsection{\textcolor{Chapter }{ChooseField}}
\logpage{[ 2, 3, 1 ]}\nobreak
\hyperdef{L}{X824D14CF818525B2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ChooseField({\mdseries\slshape F})\index{ChooseField@\texttt{ChooseField}}
\label{ChooseField}
}\hfill{\scriptsize (function)}}\\


 Workaround for the \texttt{NLFSR} object definition: we need to fix the chosen underlying finite field and
prepare indeterminates in the chosen field. The indeterminates will be used
for the multivariable polynomial, which will define the \texttt{NLFSR} feedback. Current threshold is set by global \texttt{MaxNLFSRLen} = 100. 

 }

 

\subsection{\textcolor{Chapter }{NLFSR}}
\logpage{[ 2, 3, 2 ]}\nobreak
\hyperdef{L}{X7DDE3CAC7A9D2A55}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NLFSR({\mdseries\slshape K, clist, mlist, len[, tap]})\index{NLFSR@\texttt{NLFSR}}
\label{NLFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NLFSR({\mdseries\slshape K, fieldpol, clist, mlist, len[, tap]})\index{NLFSR@\texttt{NLFSR}}
\label{NLFSR}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 An empty \texttt{NLFSR} with components \texttt{init}, \texttt{state} and \texttt{numsteps} 



 Different ways to create an \texttt{NLFSR} oblject, main difference is in creation of the underlying finite field. 

 NOTE: before creating the \texttt{NLFSR}, we must always create the indeterminates to be used for the feedback using \texttt{ChooseField} function call!!! please see example below 

 

 Inputs: 
\begin{itemize}
\item  \mbox{\texttt{\mdseries\slshape F}} - the underlying finite field (either an extension field or a prime field)
\item  \mbox{\texttt{\mdseries\slshape fieldpol}} - defifning polynomial of the extension field (must be irreducible) 
\item  \mbox{\texttt{\mdseries\slshape clist}} - list of coefficients for the monomials in \mbox{\texttt{\mdseries\slshape mlist}} 
\item  \mbox{\texttt{\mdseries\slshape mlist}} - list of monomials 
\item  \mbox{\texttt{\mdseries\slshape len}} - length of \texttt{NLFSR} 
\item  \mbox{\texttt{\mdseries\slshape tap}} - optional parameter: the output tap (must be a positive integer or a list of
positive integers) and will be changed to the default S{\textunderscore}0 if
the specified integer is out of \texttt{NLFSR}range.
\end{itemize}
 NOTE: \mbox{\texttt{\mdseries\slshape clist}} and \mbox{\texttt{\mdseries\slshape mlist}} must be of same length, all elements in \mbox{\texttt{\mdseries\slshape clist}} must belong to the underlying field. Monomials in \mbox{\texttt{\mdseries\slshape mlist}} must not include any indeterminates that are out of range specified by \mbox{\texttt{\mdseries\slshape len}}: stages of \texttt{NLFSR} are represented by indeterminants and the feedback is not allowed to use a
stage that doesnt exist. A second constraint on \mbox{\texttt{\mdseries\slshape mlist}} requires that it must contain at least one monomial of degree $>$ 1, otherwise we must create an \texttt{LFSR}. 

 Compoents: 
\begin{itemize}
\item  \texttt{init} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the initial state of the \texttt{NLFSR}, with indeces from n-1, ..., 0
\item  \texttt{state} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the current state of the \texttt{NLFSR}, with indices from n-1, ..., 0
\item  \texttt{numsteps} - the number of steps performed thus far (initialized to -1 when created, set
to 0 when loaded using \texttt{LoadFSR} (\ref{LoadFSR}) and incremented by 1 with each step (using \texttt{StepFSR} (\ref{StepFSR}))) 
\end{itemize}
 Attributes \texttt{FieldPoly} (\ref{FieldPoly}), \texttt{UnderlyingFied} (\ref{UnderlyingFied}), \texttt{MultivarPoly}, \texttt{FeedbackVec} (\ref{FeedbackVec}), \texttt{IndetList} (\ref{IndetList}), \texttt{Length} (\ref{Length}) and \texttt{OutputTap} (\ref{OutputTap}) and the property \texttt{IsNonLinearFeedback} are set during the construction of an \texttt{NLFSR}. 

 If there is something wrong with the arguments (e.g. attempting to create an
extension field using a reducible poynomial), an error message appears and the
function returns \texttt{fail}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@ F := GF(2);;  clist := [One(F), One(F)];; mlist := [x_0*x_1, x_2];;|
  Error, Variable: 'x_0' must have a value
  not in any function at line 2 of *stdin*
  !gapprompt@gap>| !gapinput@test := NLFSR(F, clist, mlist, 3);|
  Error, Variable: 'mlist' must have a value
  not in any function at line 3 of *stdin*
  !gapprompt@gap>| !gapinput@ChooseField(F);|
  You can now create an NLFSR with up to 100 stages
  with up to  100 nonzero terms
  !gapprompt@gap>| !gapinput@mlist := [x_0*x_1, x_2];;                                           |
  !gapprompt@gap>| !gapinput@test := NLFSR(F, clist, mlist, 3);|
  < empty NLFSR of length 3,
   given by MultivarPoly = x_0*x_1+x_2> 
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsNonLinearFeedback}}
\logpage{[ 2, 3, 3 ]}\nobreak
\hyperdef{L}{X7E493B9784FCFF58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNonLinearFeedback({\mdseries\slshape nlfsr})\index{IsNonLinearFeedback@\texttt{IsNonLinearFeedback}}
\label{IsNonLinearFeedback}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNLFSR({\mdseries\slshape nlfsr})\index{IsNLFSR@\texttt{IsNLFSR}}
\label{IsNLFSR}
}\hfill{\scriptsize (filter)}}\\


 For the multivariate polynomial given by \mbox{\texttt{\mdseries\slshape clist}} and \mbox{\texttt{\mdseries\slshape mlist}}, DegreeOfPolynomial greter than 1 sets \texttt{IsNonLinearFeedback} to \emph{true}. otherwise it prints out a warning that you need to use the \texttt{LFSR} constructor instead. 

 Filter \texttt{IsNLFSR} is defined as and-filter of \texttt{IsFSR} and \texttt{IsNonLinearFeedback}. 

 NOTE: at the same time \texttt{IsLinearFeedback} is set to \emph{false} (for coding purposes). }

 

\subsection{\textcolor{Chapter }{MultivarPoly}}
\logpage{[ 2, 3, 4 ]}\nobreak
\hyperdef{L}{X7C6FCBDC82C3734E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MultivarPoly({\mdseries\slshape nlfsr})\index{MultivarPoly@\texttt{MultivarPoly}}
\label{MultivarPoly}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IndetList({\mdseries\slshape nlfsr})\index{IndetList@\texttt{IndetList}}
\label{IndetList}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{MultivarPoly} holds the multivariate function defining the feedback of the \texttt{NLFSR}. \texttt{IndetList} holds all the indeterminates that are present in \texttt{MultivarPoly} and \texttt{FeedbackVec} holds only the nonzero coefficients (as opposed to the \texttt{LFSR}, where this field holds coefficients for all stages of the \texttt{FSR}). The feedback element is computed from \texttt{MultivarPoly}, \texttt{IndetList} and \texttt{state}, and not from \texttt{FeedbackVec}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@MultivarPoly(test); IndetList(test);|
  x_0*x_1+x_2
  [ 0, 1, 2 ]
  
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{Output formatting functions and TEX drawing functions}}\label{Outputs}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7F7E555B782ECF45}{}
{
  
\section{\textcolor{Chapter }{View/Display/Print/PrintAll}}\label{View}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X801108968613569C}{}
{
  

\subsection{\textcolor{Chapter }{ViewObj}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X815BF22186FD43C9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ViewObj({\mdseries\slshape lfsr})\index{ViewObj@\texttt{ViewObj}}
\label{ViewObj}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintObj({\mdseries\slshape lfsr[, b]})\index{PrintObj@\texttt{PrintObj}}
\label{PrintObj}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintAll({\mdseries\slshape lfsr[, b]})\index{PrintAll@\texttt{PrintAll}}
\label{PrintAll}
}\hfill{\scriptsize (method)}}\\


 Different detail on \mbox{\texttt{\mdseries\slshape nsr}} created either by \texttt{LFSR} (\ref{LFSR}) or \texttt{NLFSR} (\ref{NLFSR}): 
\begin{itemize}
\item  \texttt{Display/View}: 
\begin{itemize}
\item  for LFSR: show the \texttt{CharPoly} and wheter or not the \mbox{\texttt{\mdseries\slshape fsr}} is empty
\item  for NLFSR: show the \texttt{MultivarPoly} and wheter or not the \mbox{\texttt{\mdseries\slshape fsr}} is empty
\end{itemize}
 
\item  \texttt{Print}: same as \texttt{Display/View} if \mbox{\texttt{\mdseries\slshape fsr}} is empty, otherwise it also shows the values of components \texttt{state} , \texttt{numsteps} and \texttt{basis}
\item  \texttt{PrintAll}: same as \texttt{Print} if \mbox{\texttt{\mdseries\slshape fsr}} is empty, otherwise it also shows the values of all four components \texttt{init}, \texttt{state} , \texttt{numsteps} and \texttt{basis} with additional information about the underlying field and the tap positions
\end{itemize}
 Both \texttt{Print} and \texttt{PrintAll} can be used with optional parameter \mbox{\texttt{\mdseries\slshape b}} for desiered output format: when \texttt{true} the output will used the currently chosen basis. 

 Examples below show different outputs for an LFSR: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@K := GF(2);; x := X(K, "x");;|
  !gapprompt@gap>| !gapinput@f := x^4 + x^3 + 1;; F := FieldExtension(K, f);; |
  !gapprompt@gap>| !gapinput@y := X(F, "y");; l := y^4+ y+ Z(2^4);;|
  !gapprompt@gap>| !gapinput@test := LFSR(K, f, l);;|
  !gapprompt@gap>| !gapinput@Print(test);           |
  empty LFSR over GF(2^4) given by CharPoly = y^4+y+Z(2^4)
  !gapprompt@gap>| !gapinput@ist := [ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ];; LoadFSR(test, ist);|
  Z(2)^0
  !gapprompt@gap>| !gapinput@Print(test);                         |
  LFSR over GF(2^4)  given by CharPoly = y^4+y+Z(2^4)
  with basis =[ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]
  with current state =[ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ]
  after  0 steps
  !gapprompt@gap>| !gapinput@RunFSR(test,5);|
  [ Z(2^2), Z(2^4), 0*Z(2), Z(2^4)^2, Z(2^4)^11 ]
  !gapprompt@gap>| !gapinput@Print(test);   |
  LFSR over GF(2^4)  given by CharPoly = y^4+y+Z(2^4)
  with basis =[ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]
  with current state =[ Z(2^2), Z(2^4)^2, Z(2^4)^2, Z(2^4)^11 ]
  after  5 steps
  !gapprompt@gap>| !gapinput@PrintAll(test);|
  LFSR over GF(2^4)  given by CharPoly = y^4+y+Z(2^4)
  with basis =[ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]
  with feedback coeff =[ 0*Z(2), 0*Z(2), Z(2)^0, Z(2^4) ]
  with initial state  =[ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ]
  with current state  =[ Z(2^2), Z(2^4)^2, Z(2^4)^2, Z(2^4)^11 ]
  after 5 steps
  with output from stage S_0
  !gapprompt@gap>| !gapinput@ PrintAll(test, true);|
  LFSR over GF(2^4) defined by FieldPoly=x^4+x^3+Z(2)^0  given by CharPoly = y^4\
  +y+Z(2^4)
  with basis =[ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]
  with feedback coeff =[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 0, 0, 0 ], 
    [ 0, 1, 1, 0 ] ]
  with initial state  =[ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ], 
    [ 1, 0, 0, 0 ] ]
  with current state  =[ [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], 
    [ 0, 1, 1, 1 ] ]
  after 5 steps
  with output from stage S_0
  
\end{Verbatim}
 Examples below show different outputs for an NLFSR: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@ F := GF(2);; ChooseField(F);|
  You can now create an NLFSR with up to 100 stages
  with up to  100 nonzero terms
  !gapprompt@gap>| !gapinput@ clist := [One(F), One(F)];; mlist := [x_0*x_1, x_2];;|
  !gapprompt@gap>| !gapinput@ test := NLFSR(F, clist, mlist, 3);                                         |
  < empty NLFSR of length 3 over GF(2),
    given by MultivarPoly = x_0*x_1+x_2> 
  !gapprompt@gap>| !gapinput@Display(test);                                      |
  < empty NLFSR of length 3 over GF(2),
   given by MultivarPoly = x_0*x_1+x_2> 
  !gapprompt@gap>| !gapinput@PrintAll(test,true);|
  empty NLFSR of length 3 over GF(2),
    given by MultivarPoly = x_0*x_1+x_2
  with basis =[ Z(2)^0 ]
  with initial state  =[ [ 0 ], [ 0 ], [ 0 ] ]
  with current state  =[ [ 0 ], [ 0 ], [ 0 ] ]
  after initialization 
  with output from stage S_0
  
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Writing to *.txt or *.tex }}\label{Writing}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X782CBCA5787E4686}{}
{
  

\subsection{\textcolor{Chapter }{WriteAllFSR}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X78180B88800FA409}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteAllFSR({\mdseries\slshape output, fsr})\index{WriteAllFSR@\texttt{WriteAllFSR}}
\label{WriteAllFSR}
}\hfill{\scriptsize (function)}}\\


 Equivalent to PrintAll , but it writes to an output stream. NOTE: The basis
switch must be present and if \emph{true}, the currently set basis of the \mbox{\texttt{\mdseries\slshape fsr}} is used. }

 

\subsection{\textcolor{Chapter }{WriteSequenceFSR}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X79E7AA0478BA4482}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteSequenceFSR({\mdseries\slshape output, fsr, sequence})\index{WriteSequenceFSR@\texttt{WriteSequenceFSR}}
\label{WriteSequenceFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteTBSequenceFSR({\mdseries\slshape output, fsr, sequence})\index{WriteTBSequenceFSR@\texttt{WriteTBSequenceFSR}}
\label{WriteTBSequenceFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteTEXSequenceByGenerator({\mdseries\slshape output, fsr, sequence, strGen, gen})\index{WriteTEXSequenceByGenerator@\texttt{WriteTEXSequenceByGenerator}}
\label{WriteTEXSequenceByGenerator}
}\hfill{\scriptsize (function)}}\\


 \texttt{WriteSequenceFSR} writes the sequence generated by some version of RunFSR(lfsr) to *.txt file,
with addition of separating sequences from different taps and writing them in
currently set basis of the \mbox{\texttt{\mdseries\slshape fsr}}. 

 \texttt{WriteTBSequenceFSR} is a version of \texttt{WriteSequenceFSR} intended for testbenching purposes: the generated sequence is written to *.txt
file, with sequences from different taps separated into \emph{columns} separated by "\texttt{\symbol{92}}t". Again the currently set basis of the \mbox{\texttt{\mdseries\slshape fsr}} is used. The order of columns is determined by \texttt{OutputTap(\mbox{\texttt{\mdseries\slshape fsr}})}. 

 \texttt{WriteTEXSequenceByGenerator} is a *.tex version of \texttt{WriteSequenceFSR} but allows to write the sequence elements as powers of a chosen generator \mbox{\texttt{\mdseries\slshape gen}}. Generator \mbox{\texttt{\mdseries\slshape gen}} is used to get the exponents of the elements, and the elements themselfs are
printed as \$\texttt{\symbol{92}}\mbox{\texttt{\mdseries\slshape strGen}}\texttt{\symbol{94}}\texttt{\symbol{123}}exponent\texttt{\symbol{125}}\$,
where strGen must be a string representing a greek letter in *.tex, for
example \mbox{\texttt{\mdseries\slshape strGen}} "alpha" will give $\alpha$. }

 

\subsection{\textcolor{Chapter }{WriteRunFSR}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X7C33BF5C835DBEEC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteRunFSR({\mdseries\slshape output, lfsr, ist, numsteps})\index{WriteRunFSR@\texttt{WriteRunFSR}}
\label{WriteRunFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteNonlinRunFSR({\mdseries\slshape output, lfsr, ist, numsteps})\index{WriteNonlinRunFSR@\texttt{WriteNonlinRunFSR}}
\label{WriteNonlinRunFSR}
}\hfill{\scriptsize (function)}}\\


 \texttt{WriteRunFSR} is an output to *.txt version of RunFSR(\mbox{\texttt{\mdseries\slshape fsr}}, \mbox{\texttt{\mdseries\slshape ist}}, \mbox{\texttt{\mdseries\slshape num}}), with addition of separating sequences from different taps and writing them
in currently set basis of the \mbox{\texttt{\mdseries\slshape fsr}}. Before the run begins and after loading, the \texttt{WriteAllFSR(output, x, true)} is called to record the FSR being used. When the run is finished, \texttt{WriteSequenceFSR} is called to record the output sequence in compact version. \texttt{WriteRunFSR} returns the sequence generated by this run. 

 \texttt{WriteNonlinRunFSR} is an output to *.txt version of RunFSR(\mbox{\texttt{\mdseries\slshape fsr}}, \mbox{\texttt{\mdseries\slshape ist}}, \mbox{\texttt{\mdseries\slshape elmvec}}). \texttt{WriteNonlinRunFSR} returns a sequence generated by this run, however, the length of returned
sequence is Length(\mbox{\texttt{\mdseries\slshape elmvec}})+1, because the first element of the output sequence is the element that was
loaded with \mbox{\texttt{\mdseries\slshape ist}}. }

 

\subsection{\textcolor{Chapter }{WriteTEXRunFSR}}
\logpage{[ 3, 2, 4 ]}\nobreak
\hyperdef{L}{X7B88931878142E55}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteTEXRunFSR({\mdseries\slshape output, fsr, ist, numsteps})\index{WriteTEXRunFSR@\texttt{WriteTEXRunFSR}}
\label{WriteTEXRunFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteTEXNonlinRunFSR({\mdseries\slshape output, fsr, ist, numsteps})\index{WriteTEXNonlinRunFSR@\texttt{WriteTEXNonlinRunFSR}}
\label{WriteTEXNonlinRunFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteTEXRunFSRByGenerator({\mdseries\slshape output, fsr, ist, numsteps, strGen, gen})\index{WriteTEXRunFSRByGenerator@\texttt{WriteTEXRunFSRByGenerator}}
\label{WriteTEXRunFSRByGenerator}
}\hfill{\scriptsize (function)}}\\


 \texttt{WriteTEXRunFSR} is an output to *.tex version of RunFSR(\mbox{\texttt{\mdseries\slshape fsr}}, \mbox{\texttt{\mdseries\slshape ist}}, \mbox{\texttt{\mdseries\slshape num}}), which writes a table that can be included dircetly (except for the label).
Rows of the table represent the steps of the FSR and include the state of the
FSR and the elements from stages specfied by outputTap, that is the sequence
outputs at this step. The table entries (FFEs) are printed using currently set
basis of the \mbox{\texttt{\mdseries\slshape fsr}}. When the run is finished, \texttt{WriteTEXSequenceByGenerator} is called to record the output sequence in compact version. \texttt{WriteTEXRunFSR} returns the sequence generated by this run. 

 \texttt{WriteTEXNonlinRunFSR} TO DO 

 \texttt{WriteTEXRunFSRByGenerator} is a *.tex version of \texttt{WriteTEXRunFSR} but instead of using the currently set basis of the \mbox{\texttt{\mdseries\slshape fsr}}, the table entries are printed as powers of a chosen generator \mbox{\texttt{\mdseries\slshape gen}}. Generator \mbox{\texttt{\mdseries\slshape gen}} is used to get the exponents of the elements, and the elements themselfs are
printed as \$\texttt{\symbol{92}}\mbox{\texttt{\mdseries\slshape strGen}}\texttt{\symbol{94}}\texttt{\symbol{123}}exponent\texttt{\symbol{125}}\$,
where \mbox{\texttt{\mdseries\slshape strGen}} must be a string representing a greek letter in *.tex, for example \mbox{\texttt{\mdseries\slshape strGen}} "alpha" will give $\alpha$. }

 

\subsection{\textcolor{Chapter }{WriteTEXElementTableByGenerator}}
\logpage{[ 3, 2, 5 ]}\nobreak
\hyperdef{L}{X7E69E0BC8080C5AF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteTEXElementTableByGenerator({\mdseries\slshape output, F, B, strGen, gen})\index{WriteTEXElementTableByGenerator@\texttt{WriteTEXElementTableByGenerator}}
\label{WriteTEXElementTableByGenerator}
}\hfill{\scriptsize (function)}}\\


 \texttt{WriteTEXElementTableByGenerator} provides the context information for \texttt{WriteTEXSequenceByGenerator} and \texttt{WriteTEXRunFSRByGenerator}. Its output is a *.tex file with a table containing the elements of \mbox{\texttt{\mdseries\slshape F}} represented in basis \mbox{\texttt{\mdseries\slshape B}} and their representation as powers of a chosen generator \mbox{\texttt{\mdseries\slshape gen}}, printed as \$\texttt{\symbol{92}}\mbox{\texttt{\mdseries\slshape strGen}}\texttt{\symbol{94}}\texttt{\symbol{123}}exponent\texttt{\symbol{125}}\$,
where by the greek letter passed to the function as a string \mbox{\texttt{\mdseries\slshape strGen}}. There is an extra table column containing the order of each element. 

 The output file contains additional information: defining polynomial of \mbox{\texttt{\mdseries\slshape F}}, basis elements of \mbox{\texttt{\mdseries\slshape B}} as powers of generator \mbox{\texttt{\mdseries\slshape gen}}, and information whether or not \mbox{\texttt{\mdseries\slshape gen}} is a root of the defining polynomial. }

 }

 
\section{\textcolor{Chapter }{TEX drawing functions}}\label{Drawing}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X84E367F97DBA31D2}{}
{
  }

 }

 
\chapter{\textcolor{Chapter }{misc - helper functions}}\label{misc}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X82DB6D4585397594}{}
{
  
\section{\textcolor{Chapter }{Output formatting functions}}\label{outputs}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7EB095598359B4B3}{}
{
  \index{outputs} There are two types of functions: ones that return the input in a human
friendly version (as strings or list of strings), and ones that write the
human friendly version of the input into a file (txt or tex) 

\subsection{\textcolor{Chapter }{IntFFExt}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X7C848712781083D5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IntFFExt({\mdseries\slshape [B, ]ffe})\index{IntFFExt@\texttt{IntFFExt}}
\label{IntFFExt}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IntVecFFExt({\mdseries\slshape [B, ]vec})\index{IntVecFFExt@\texttt{IntVecFFExt}}
\label{IntVecFFExt}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IntMatFFExt({\mdseries\slshape [B, ]M})\index{IntMatFFExt@\texttt{IntMatFFExt}}
\label{IntMatFFExt}
}\hfill{\scriptsize (method)}}\\


 \texttt{IntFFExt} takes the \mbox{\texttt{\mdseries\slshape ffe}} and writes it as an integer of the prime field if \mbox{\texttt{\mdseries\slshape ffe}} is an element of the prime field (same as Int(ffe)), or writes it as a vector
of integers from the prime subfield if \mbox{\texttt{\mdseries\slshape ffe}} is an element of an extension field, using the given basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}} if no basis is provided. 

 \texttt{IntVecFFExt} takes the vector \mbox{\texttt{\mdseries\slshape vec}} of FFEs and writes it in a human friendly version: as a vector of integers
from the prime field if all components of \mbox{\texttt{\mdseries\slshape vec}} belong to a prime field, or as a vector of vectors of integers from the prime
subfield, if the components belong to an extension field, using the given
basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}}, if no basis is provided. (note: all components are treated as elements of
the largest field). 

 \texttt{IntMatFFExt} takes a matrix \mbox{\texttt{\mdseries\slshape M}} and returns its human friendly version: a matrix of vectors of integers from
the prime field if all components of \mbox{\texttt{\mdseries\slshape M}} belong to a prime field, or a vector of row vectors, whose elements are
vectors of integers from the prime subfield, if the components belong to an
extension field, using the given basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of components of \mbox{\texttt{\mdseries\slshape M}}. 

 NOTE: the non-basis versions return a representation in the smallest field
that contains the element. For representation in a specific field, use the
basis version with desired basis. }

 

\subsection{\textcolor{Chapter }{VecToString}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X78387B8B7940F96C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VecToString({\mdseries\slshape [B, ]vec})\index{VecToString@\texttt{VecToString}}
\label{VecToString}
}\hfill{\scriptsize (method)}}\\


 Writes a FFE verctor or matrix as string or list of strings using the given
basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}} if no basis is provided. This mathod calls methods \texttt{IntFFExt}, \texttt{IntVecFFExt} and \texttt{IntMatFFExt} from section LINK. The list of strings is more practically useful: we wish to
have the components as srings, therefore the human friendly version of a
matrix is not an actual string. 

 NOTE: the non-basis versions return a representation in the cononical basis of
the smallest field that contains the element. For representation in a specific
field, use the basis version with desired basis. }

 

\subsection{\textcolor{Chapter }{WriteVector (for a FFE and given basis)}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X7F4DA7FE7C10E782}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteVector({\mdseries\slshape output, B, vec})\index{WriteVector@\texttt{WriteVector}!for a FFE and given basis}
\label{WriteVector:for a FFE and given basis}
}\hfill{\scriptsize (function)}}\\


 Writes the human friendly version of vector \mbox{\texttt{\mdseries\slshape vec}} represented in basis \mbox{\texttt{\mdseries\slshape B}}, to the output file \mbox{\texttt{\mdseries\slshape output}}. Also works if \mbox{\texttt{\mdseries\slshape vec}} is an integer or FFE. can be used to write the sequence produced by the FSR to
a file, make sure that the sequence does not contain any subsequences (ie if
merging two runs of the FSR, must use Append(seq,seq1), if adding new step to
a run must use Add(seq, elm1)) 

 NOTE: the basis MUST be provided. 

 Also works for writing matrices, but writes them as a row vector, not as a
rectangle. }

 

\subsection{\textcolor{Chapter }{WriteMatrix (for a matrix of FFE and given basis)}}
\logpage{[ 4, 1, 4 ]}\nobreak
\hyperdef{L}{X7FB7643986FE0503}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteMatrix({\mdseries\slshape output, B, M})\index{WriteMatrix@\texttt{WriteMatrix}!for a matrix of FFE and given basis}
\label{WriteMatrix:for a matrix of FFE and given basis}
}\hfill{\scriptsize (function)}}\\


 Writes the human friendly version of matrix \mbox{\texttt{\mdseries\slshape M}} represented in basis \mbox{\texttt{\mdseries\slshape B}} to the output file \mbox{\texttt{\mdseries\slshape output}} nicely formatted (rectangular, each row in a new line). 

 NOTE: the basis MUST be provided. }

 

\subsection{\textcolor{Chapter }{WriteMatrixTEX}}
\logpage{[ 4, 1, 5 ]}\nobreak
\hyperdef{L}{X7C88DF8385B5C384}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteMatrixTEX({\mdseries\slshape output, M})\index{WriteMatrixTEX@\texttt{WriteMatrixTEX}}
\label{WriteMatrixTEX}
}\hfill{\scriptsize (function)}}\\


 Writes the TEX code for matrix \mbox{\texttt{\mdseries\slshape M}} over a prime field to the output file \mbox{\texttt{\mdseries\slshape output}}. 

 NOTE: Only works for matrices over a prime field !!! }

 }

 
\section{\textcolor{Chapter }{misc - helper functions}}\label{misc}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X82DB6D4585397594}{}
{
  

\subsection{\textcolor{Chapter }{MonomialsOverField (for an NLFSR)}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X7CF7FC2182FEA652}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MonomialsOverField({\mdseries\slshape F, poly})\index{MonomialsOverField@\texttt{MonomialsOverField}!for an NLFSR}
\label{MonomialsOverField:for an NLFSR}
}\hfill{\scriptsize (method)}}\\


 MonomialsOverField reduces takes a monomial or a list of monomials, and
reduces all the exponents modulo (Size(\mbox{\texttt{\mdseries\slshape F}})-1) for all extension fields and prime fields except for \mbox{\texttt{\mdseries\slshape F}}=$\mathcal(F)_2$. For $\mathcal(F)_2$ all the exponents are set to 1. }

 

\subsection{\textcolor{Chapter }{DegreeOfPolynomial (DegreeOfPolynomial)}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X85A860DA845F6090}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DegreeOfPolynomial({\mdseries\slshape F, poly})\index{DegreeOfPolynomial@\texttt{DegreeOfPolynomial}!DegreeOfPolynomial}
\label{DegreeOfPolynomial:DegreeOfPolynomial}
}\hfill{\scriptsize (method)}}\\


 \texttt{DegreeOfPolynomial} as follows for both monomial of form $p = \prod x_i^{e_i}$ and polynomial of form $P = \sum c_j\cdotp_j$ where $p_j = \prod_{i}x_i^{e_i}$ DegreeOfPolynomial for a monomial: $= \sum e_i$, where $i$ runs through all indeterminates present in this monomial 

 DegreeOfPolynomial for a polynomial:$= \max (DegreeOfPolynomial(p_j))$, where $\max$ runs through all monomials $p_j$ present in this polynomial so an actual extra funstion called DegreeOfMonomial
is not needed }

 

\subsection{\textcolor{Chapter }{GeneratorOfUnderlyingField}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X7FA03D87821F2390}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneratorOfUnderlyingField({\mdseries\slshape F})\index{GeneratorOfUnderlyingField@\texttt{GeneratorOfUnderlyingField}}
\label{GeneratorOfUnderlyingField}
}\hfill{\scriptsize (method)}}\\


 \texttt{GeneratorOfUnderlyingField} returns the first element $\ni: order(x)=Size(F)-1$ }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{manual}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
