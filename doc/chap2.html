<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (fsr) - Chapter 2: FSR (Feedback Shift Register)</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X7D2B014884E6D3D8" name="X7D2B014884E6D3D8"></a></p>
<div class="ChapSects"><a href="chap2.html#X7D2B014884E6D3D8">2 <span class="Heading">FSR (Feedback Shift Register)</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7D5E0FF97CA51E2E">2.1 <span class="Heading">Common functionality</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X867B95117FAEC3E6">2.1-1 IsFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X828F246B82428CC9">2.1-2 FieldPoly</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X780769238600AFD1">2.1-3 Length</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X865130F47A6843E5">2.1-4 ChangeBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F800DCF810E2532">2.1-5 LoadFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X82A7CA487ECAEFD5">2.1-6 StepFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X86AAB63D8781648A">2.1-7 RunFSR</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7A98C0FE855337A7">2.2 <span class="Heading">LFSR specific funcionality</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8099A9DC86E0B078">2.2-1 LFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80DF9A3D7B1E3E92">2.2-2 IsLinearFeedback</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D4D9DCC7B4BE3ED">2.2-3 CharPoly</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X81AC5D2D832C346A">2.2-4 IsPeriodic</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X797E9B3381339AB2">2.3 <span class="Heading">NLFSR specific funcionality</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X824D14CF818525B2">2.3-1 ChooseField</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7DDE3CAC7A9D2A55">2.3-2 NLFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E493B9784FCFF58">2.3-3 IsNonLinearFeedback</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C6FCBDC82C3734E">2.3-4 MultivarPoly</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">FSR (Feedback Shift Register)</span></h3>

<p><a id="X7D5E0FF97CA51E2E" name="X7D5E0FF97CA51E2E"></a></p>

<h4>2.1 <span class="Heading">Common functionality</span></h4>

<p>We define an object <strong class="pkg">FSR</strong> (Feedback Shift Register), which can come in two flavours: with linear feedback <code class="func">LFSR</code> (<a href="chap2.html#X8099A9DC86E0B078"><span class="RefLink">2.2-1</span></a>) and nonlinear feedback <code class="func">NLFSR</code> (<a href="chap2.html#X7DDE3CAC7A9D2A55"><span class="RefLink">2.3-2</span></a>). Because of many similarities between the two, the basic common functionality can be found here, while specialized functions (such as <code class="code">LFSR</code> and <code class="code">NLFSR</code> object creation) in corresponding sections.</p>

<p><a id="X867B95117FAEC3E6" name="X867B95117FAEC3E6"></a></p>

<h5>2.1-1 IsFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFSR</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>This is the category of <code class="code">FSR</code> objects. Objects in this category are created using functions <code class="func">LFSR</code> (<a href="chap2.html#X8099A9DC86E0B078"><span class="RefLink">2.2-1</span></a>) or <code class="func">NLFSR</code> (<a href="chap2.html#X7DDE3CAC7A9D2A55"><span class="RefLink">2.3-2</span></a>).</p>

<p><a id="X828F246B82428CC9" name="X828F246B82428CC9"></a></p>

<h5>2.1-2 FieldPoly</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FieldPoly</code>( <var class="Arg">fsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingField</code>( <var class="Arg">fsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FeedbackVec</code>( <var class="Arg">fsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutputTap</code>( <var class="Arg">fsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><code class="code">FieldPoly</code> of the <var class="Arg">fsr</var> stores the irreducible polynomial used to construct the extension field or 1 in case of a prime field.</p>

<p><code class="code">UnderlyingField</code> of the <var class="Arg">fsr</var> is the finite field over which the <var class="Arg">fsr</var> is defined (all indeterminates and constants are from this field).</p>

<p>NOTE: it may seem redundant to sore both <code class="code">FieldPoly</code> and <code class="code">UnderlyingField</code>, however, they are used by other functions in the package.</p>

<p><code class="code">FeedbackVec</code> of the <var class="Arg">fsr</var> stores the coefficients of the <code class="code">CharPoly</code> without its leading term in case of <code class="code">LFSR</code>, and coefficients of the nonzero monomials present in the multivariate function defining the feedback in case of <code class="code">NLFSR</code>.</p>

<p><code class="code">OutputTap</code> holds the output tap position(s): the sequence elements are taken from the stage(s) listed in <code class="code">OutputTap</code>.</p>

<p><a id="X780769238600AFD1" name="X780769238600AFD1"></a></p>

<h5>2.1-3 Length</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Length</code>( <var class="Arg">fsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InternalStateSize</code>( <var class="Arg">fsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Threshold</code>( <var class="Arg">fsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><code class="code">Length</code> of the <var class="Arg">fsr</var> is the number of its stages.</p>

<p><code class="code">InternalStateSize</code> of the <var class="Arg">fsr</var> is size in bits needed to store the state <span class="SimpleMath">length ⋅ width</span>, where <span class="SimpleMath">width = DegreeOverPrimeField(UnderlyingField(<var class="Arg">fsr</var>))</span>.</p>

<p><code class="code">Threshold</code> of the <var class="Arg">fsr</var> is currently set to <span class="SimpleMath">Characteristic(<var class="Arg">fsr</var>)^t+ℓ</span>, where <span class="SimpleMath">t=InternalStateSize(<var class="Arg">fsr</var>)</span> and <span class="SimpleMath">ℓ=Length(<var class="Arg">fsr</var>)</span>.</p>

<p><a id="X865130F47A6843E5" name="X865130F47A6843E5"></a></p>

<h5>2.1-4 ChangeBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ChangeBasis</code>( <var class="Arg">fsr</var>, <var class="Arg">B</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WhichBasis</code>( <var class="Arg">fsr</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><code class="code">ChangeBasis</code> allows changing the basis of the <var class="Arg">fsr</var> to basis <var class="Arg">B</var>. Basis B must be given for <code class="code">UnderlyingField(fsr)</code> over its prime subfield.</p>

<p><code class="code">WhichBasis</code> returns the basis currently set for the <var class="Arg">fsr</var>. Elements in the <var class="Arg">fsr</var> state are still represented in GAP native representation, but the functions with basis switch turned on will print the elements w.r.t to currently set basis.</p>

<p><a id="X7F800DCF810E2532" name="X7F800DCF810E2532"></a></p>

<h5>2.1-5 LoadFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LoadFSR</code>( <var class="Arg">fsr</var>, <var class="Arg">ist</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Loading the <var class="Arg">fsr</var> with the initial state <var class="Arg">ist</var>, which is a <var class="Arg">FFE</var> vector of same length as <var class="Arg">fsr</var> and with elements from its underlying finite field. If either of those two requirements is violated, loading fails and error message appears. At the time of loading the initial sequence elements (ie zeroth elements) are obtained and <code class="code">numsteps</code> is set to 0.</p>

<p><a id="X82A7CA487ECAEFD5" name="X82A7CA487ECAEFD5"></a></p>

<h5>2.1-6 StepFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StepFSR</code>( <var class="Arg">fsr</var>[, <var class="Arg">elm</var>] )</td><td class="tdright">( method )</td></tr></table></div>
<p>Perform one step the <var class="Arg">fsr</var>, ie. compute the new <code class="code">state</code> and update the <code class="code">numsteps</code>, then output the elements denoted by <code class="code">OutputTap</code>. If the optional parameter <var class="Arg">elm</var> is used then the new element is computed as a sum of computed feedback and <var class="Arg">elm</var>. Elemen <var class="Arg">elm</var> must be an element of the underlying finite field.</p>

<p>As this is a way to destroy the linearity of an <code class="code">LFSR</code>, we refer to <code class="code">StepFSR</code> with the optiomal nonzero <var class="Arg">elm</var> as <code class="code">nonlinear step</code>. Similarly, the <code class="code">NLFSR</code> can also have an extra element added to the (already nonlinear) feedback.</p>

<p>Returns an error if the <var class="Arg">fsr</var> is not loaded!</p>

<p><a id="X86AAB63D8781648A" name="X86AAB63D8781648A"></a></p>

<h5>2.1-7 RunFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RunFSR</code>( <var class="Arg">fsr</var>[, <var class="Arg">ist</var>, <var class="Arg">num</var>, <var class="Arg">pr</var>] )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RunFSR</code>( <var class="Arg">fsr</var>, <var class="Arg">elm</var>[, <var class="Arg">num</var>, <var class="Arg">pr</var>] )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RunFSR</code>( <var class="Arg">fsr</var>, <var class="Arg">ist</var>, <var class="Arg">elmvec</var>[, <var class="Arg">pr</var>] )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RunFSR</code>( <var class="Arg">fsr</var>, <var class="Arg">z</var>, <var class="Arg">elmvec</var>[, <var class="Arg">pr</var>] )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: A sequence of elements generated by <code class="code">FSR</code>.</p>

<p>The <var class="Arg">fsr</var> will be run for <span class="SimpleMath">min(<var class="Arg">num</var> , Threshold(<var class="Arg">fsr</var>))</span> number of steps: value Threshold(<var class="Arg">fsr</var>) is used by all versions without explicit <var class="Arg">num</var> and enforced when <var class="Arg">num</var> exceeds Threshold(<var class="Arg">fsr</var>). There is an optional printing switch <var class="Arg">pr</var>, with default set to <em>false</em>; if <em>true</em> then the state and the output sequence element(s) are printed in <strong class="pkg">GAP</strong> shell on every step of the <var class="Arg">fsr</var> (we call this output for <code class="code">RunFSR</code>), and the currently set basis <var class="Arg">B</var> is used for representation of elements.</p>


<ul>
<li><p><code class="code">RunFSR(<var class="Arg"> fsr[, num, pr] </var>)</code> - run <var class="Arg">fsr</var> for <var class="Arg">num</var>/<var class="Arg">threshold</var> steps with/without output</p>

</li>
<li><p><code class="code">RunFSR(<var class="Arg"> fsr, ist[, num, pr] </var>)</code> - load <var class="Arg">fsr</var> with <var class="Arg">ist</var>, then run <var class="Arg">fsr</var> for <var class="Arg">num</var>/<var class="Arg">threshold</var> steps with/without output (ie. <em>linear</em> version)</p>

</li>
<li><p><code class="code">RunFSR(<var class="Arg"> fsr, elm[, num, pr] </var>)</code> - run <var class="Arg">fsr</var> for <var class="Arg">num</var>/<var class="Arg">threshold</var> steps, whereby the SAME element <var class="Arg">elm</var> is added to the feedback at each step, with/without output (ie. <em>non-linear</em> version)</p>

</li>
<li><p><code class="code">RunFSR(<var class="Arg"> fsr, ist, elmvec[, pr] </var>)</code> - load <var class="Arg">fsr</var> with <var class="Arg">ist</var>, then run <var class="Arg">fsr</var> for <em>Length(<var class="Arg">elmvec</var>)</em> steps, whereby one element of <var class="Arg">elmvec</var> is added to the feedback at each step (starting with <var class="Arg">elmvec[1]</var>), with/without output (ie. <em>non-linear</em> version). NOTE: the sequence returned has length <em>Length(elmvec)+1</em>, because the zeroth sequence element is returned at the time of loading the <code class="code">FSR</code>.</p>

</li>
<li><p><code class="code">RunFSR(<var class="Arg"> fsr, z, elmvec[, pr] </var>)</code> - input <var class="Arg">z</var> must be set to 0 to indicate we want to continue a run with new <var class="Arg">elmvec</var>: run <var class="Arg">fsr</var> for <em>Length(<var class="Arg">elmvec</var>)</em> steps, whereby one element of <var class="Arg">elmvec</var> is added to the feedback at each step (starting with <var class="Arg">elmvec[1]</var>), with/without output (ie. <em>non-linear</em> version). NOTE: the sequence returned has length <em>Length(elmvec)</em>.</p>

</li>
</ul>
<p>For the load and run versions, element seq<span class="SimpleMath">_0</span> is a part of the output sequence, hence the output sequence has the length <var class="Arg">num+1</var>/<var class="Arg">threshold+1</var>/<var class="Arg">Length(elmvec)+1</var>.</p>

<p>For versions without the loading of <var class="Arg">ist</var>, calling <code class="code">RunFSR</code> returns an error if the <var class="Arg">fsr</var> is not loaded!</p>

<p>The ouput of <code class="code">RunFSR</code> is:</p>


<ul>
<li><p>sequence of <var class="Arg">FFE</var>s : seq<span class="SimpleMath">_0</span>, seq<span class="SimpleMath">_1</span>, seq<span class="SimpleMath">_2</span>, <span class="SimpleMath">dots ,</span> for <em>Length</em>(<em>OutputTap</em>)=1</p>

</li>
<li><p>sequence of vectors, each of them with <span class="SimpleMath">t</span> <var class="Arg">FFE</var>s : seq<span class="SimpleMath">_0</span>, seq<span class="SimpleMath">_1</span>, seq<span class="SimpleMath">_2</span>, <span class="SimpleMath">dots ,</span> where seq<span class="SimpleMath">_i=(</span> seq<span class="SimpleMath">_i1</span>, <span class="SimpleMath">dots ,</span> seq<span class="SimpleMath">_it</span>) for <em>Length</em>(<em>OutputTap</em>)=t</p>

</li>
</ul>
<p>Example of <code class="code">RunFSR</code> called for an lfsr <em>test</em> over <span class="SimpleMath">F_2^4</span>, with initial state <em>ist</em>, print switch <em>true</em> for basis <em>B</em>, with run length 5:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := GF(2);; x := X(K, "x");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := x^4 + x^3 + 1;; F := FieldExtension(K, f);; B := Basis(F);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := X(F, "y");; l := y^4+ y+ Z(2^4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := LFSR(K, f, l);;</span>
&lt; empty LFSR given by CharPoly = y^4+y+Z(2^4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ist :=[0*Z(2), Z(2^4), Z(2^4)^5, Z(2)^0 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RunFSR(test, ist, 5, true);             </span>
using basis B := [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]	
elm			[ 3,	...	...,0 ]  with taps  [ 0 ]
  [ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ], [ 1, 0, 0, 0 ] ]
							[ 1, 0, 0, 0 ]
	[ [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ] ]
							[ 1, 1, 0, 1 ]
	[ [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ] ]
							[ 0, 1, 1, 0 ]
	[ [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ] ]
							[ 0, 0, 0, 0 ]
	[ [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ] ]
							[ 1, 0, 1, 1 ]
	[ [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ] ]
							[ 0, 1, 1, 1 ]
[ Z(2)^0, Z(2^2), Z(2^4), 0*Z(2), Z(2^4)^2, Z(2^4)^11 ]

</pre></div>

<p>Example of <code class="code">RunFSR</code> called for an lfsr <em>test</em> over <span class="SimpleMath">F_2^4</span>, with initial state <em>ist</em>, print switch <em>true</em> for basis <em>B</em>, with 5 nonlinear inputs :</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elmvec := [Z(2^4)^2, Z(2^4)^2, Z(2^2), Z(2^4)^7, Z(2^4)^6];;                                </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RunFSR(test, ist, elmvec, true);                         </span>
using basis B := [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]	
elm		[ 3,	...	...,0 ]  with taps  [ 0 ]
[ 0, 0, 0, 0 ]		[ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ],
 [ 1, 0, 0, 0 ] ]		[ 1, 0, 0, 0 ]
[ 1, 0, 1, 1 ]		[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ],
 [ 1, 1, 0, 1 ] ]		[ 1, 1, 0, 1 ]
[ 1, 0, 1, 1 ]		[ [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],
 [ 0, 1, 1, 0 ] ]		[ 0, 1, 1, 0 ]
[ 1, 1, 0, 1 ]		[ [ 0, 1, 1, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ],
 [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
[ 0, 1, 0, 0 ]		[ [ 0, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 0 ],
 [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
[ 0, 0, 0, 1 ]		[ [ 1, 1, 0, 1 ], [ 0, 1, 0, 0 ], [ 0, 1, 1, 0 ],
 [ 1, 1, 0, 0 ] ]		[ 1, 1, 0, 0 ]
[ Z(2^4)^9, Z(2^2), Z(2^4), 0*Z(2), 0*Z(2), Z(2^4)^9 ]

</pre></div>

<p>In both examples above the there is a column <em>elm</em>, which is in first case empty, because we are not adding nonlinear inputs to the feedback, while in the second example, this column shows the element being added at each step (empty in first row - the loading step). Also note that the two examples above use the call <code class="code">LoadFSR</code>, which adds the elm seq<span class="SimpleMath">{_0}</span> to the sequence, so both sequences above are of length <var class="Arg">num+1</var>/<var class="Arg">Length(elmvec)+1</var>, ie 6. The last row in both examples is the actual sequence obtained from this run, and is kept in Zechs logarithm representation.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RunFSR(test,  ist); Length(last);</span>
[ Z(2)^0, Z(2^2), Z(2^4), 0*Z(2), Z(2^4)^2, Z(2^4)^11, Z(2^4)^2, Z(2^4)^2,
 Z(2^2), Z(2^4)^7, Z(2^4)^6, Z(2^4)^11, Z(2^2)^2, Z(2^4)^14, Z(2^4)^8,
  Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4), Z(2^4)^2, Z(2^4)^9 ]
21

</pre></div>

<p>Last example above shows a sequence of length 21, ie <var class="Arg">threshold+1</var>, getting first sequence element from LoadFSR followed by <var class="Arg">threshold</var> iterations of StepFSR.</p>

<p><a id="X7A98C0FE855337A7" name="X7A98C0FE855337A7"></a></p>

<h4>2.2 <span class="Heading">LFSR specific funcionality</span></h4>

<p><a id="X8099A9DC86E0B078" name="X8099A9DC86E0B078"></a></p>

<h5>2.2-1 LFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LFSR</code>( <var class="Arg">F</var>, <var class="Arg">charpol</var>[, <var class="Arg">B</var>, <var class="Arg">tap</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LFSR</code>( <var class="Arg">K</var>, <var class="Arg">fieldpol</var>, <var class="Arg">charpol</var>[, <var class="Arg">B</var>, <var class="Arg">tap</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LFSR</code>( <var class="Arg">F</var>, <var class="Arg">charpol</var>[, <var class="Arg">B</var>, <var class="Arg">tap</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LFSR</code>( <var class="Arg">p</var>, <var class="Arg">m</var>, <var class="Arg">n</var>[, <var class="Arg">tap</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An empty <code class="code">LFSR</code> with components <code class="code">init</code>, <code class="code">state</code> , <code class="code">numsteps</code> and <code class="code">basis</code></p>

<p>Different ways to create an <code class="code">LFSR</code> oblject, main difference is in creation of the underlying finite field.</p>

<p>Inputs:</p>


<ul>
<li><p><var class="Arg">F</var> - the underlying finite field (either an extension field or a prime field)</p>

</li>
<li><p><var class="Arg">B</var> - basis of F over its prime subfield</p>

</li>
<li><p><var class="Arg">charpol</var> - <code class="code">LFSR</code> dfining polynomial</p>

</li>
<li><p><var class="Arg">fieldpol</var> - defifning polynomial of the extension field (must be irreducible)</p>

</li>
<li><p><var class="Arg">p</var> - characteeristic</p>

</li>
<li><p><var class="Arg">m</var> - degree of extension (degree of <var class="Arg">fieldpol</var>)</p>

</li>
<li><p><var class="Arg">n</var> - length of <code class="code">LFSR</code> (degree of <var class="Arg">charpoly</var>)</p>

</li>
<li><p><var class="Arg">tap</var> - optional parameter: the output tap (must be a positive integer or a list of positive integers) and will be changed to the default S_0 if the specified integer is out of <code class="code">LFSR</code> range.</p>

</li>
</ul>
<p>Compoents:</p>


<ul>
<li><p><code class="code">init</code> - <var class="Arg">FFE</var> vector of length n=deg(charpol), storing the initial state of the <code class="code">LFSR</code>, with indeces from n-1, ..., 0</p>

</li>
<li><p><code class="code">state</code> - <var class="Arg">FFE</var> vector of length n=deg(charpol), storing the current state of the <code class="code">LFSR</code>, with indeces from n-1, ..., 0</p>

</li>
<li><p><code class="code">numsteps</code> - the number of steps performed thus far (initialized to -1 when created, set to 0 when loaded using <code class="func">LoadFSR</code> (<a href="chap2.html#X7F800DCF810E2532"><span class="RefLink">2.1-5</span></a>) and incremented by 1 with each step (using <code class="func">StepFSR</code> (<a href="chap2.html#X82A7CA487ECAEFD5"><span class="RefLink">2.1-6</span></a>)))</p>

</li>
<li><p><code class="code">basis</code> - basis of F over its prime subfield (if no basis is given this field is set to canonical basis of F over its prime subfield)</p>

</li>
</ul>
<p>Attributes <code class="func">FieldPoly</code> (<a href="chap2.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>), <code class="func">UnderlyingFied</code> (<span class="RefLink">???</span>), <code class="code">CharPoly</code>, <code class="func">FeedbackVec</code> (<a href="chap2.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>), <code class="func">Length</code> (<a href="chap2.html#X780769238600AFD1"><span class="RefLink">2.1-3</span></a>) and <code class="func">OutputTap</code> (<a href="chap2.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>) and the property <code class="code">IsLinearFeedback</code> are set during the construction of an<code class="code">LFSR</code>.</p>

<p>If there is something wrong with the arguments (e.g. attempting to create an extension field using a reducible poynomial), an error message appears and the function returns <code class="code">fail</code>.</p>

<p>Example below shows how to create an empty <code class="code">LFSR</code> over <span class="SimpleMath">F_2^4</span> created as extension of <span class="SimpleMath">F_2</span>, called <em>test</em>, firstly without a specified basis, and then with basis <var class="Arg">B</var>:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := GF(2);; x := X(K, "x");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := x^4 + x^3 + 1;; F := FieldExtension(K, f);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := X(F, "y");; l := y^4+ y+ Z(2^4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := LFSR(K, f, l);</span>
&lt; empty LFSR given by CharPoly = y^4+y+Z(2^4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WhichBasis(test);</span>
CanonicalBasis( GF(2^4) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Basis(F, Conjugates(Z(2^4)^3));;  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := LFSR(K, f, l, B);</span>
&lt; empty LFSR given by CharPoly = y^4+y+Z(2^4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WhichBasis(test);        </span>
Basis( GF(2^4), [ Z(2^4)^3, Z(2^4)^6, Z(2^4)^12, Z(2^4)^9 ] )

</pre></div>

<p><a id="X80DF9A3D7B1E3E92" name="X80DF9A3D7B1E3E92"></a></p>

<h5>2.2-2 IsLinearFeedback</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLinearFeedback</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLFSR</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( filter )</td></tr></table></div>
<p>If we were to represent the <var class="Arg">lsfr</var> with a multivariate polynomial, DegreeOfPolynomial would return 1 - the feedback polynomial is linear and <code class="code">IsLinearFeedback</code> is set to <em>true</em>. (ie. only linear terms are present: monomials with only one variable )</p>

<p>Filter <code class="code">IsLFSR</code> is defined as and-filter of <code class="code">IsFSR</code> and <code class="code">IsLinearFeedback</code>.</p>

<p><a id="X7D4D9DCC7B4BE3ED" name="X7D4D9DCC7B4BE3ED"></a></p>

<h5>2.2-3 CharPoly</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharPoly</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Attribute holding the characteristic polynomial (the feedback polynomial).</p>

<p><a id="X81AC5D2D832C346A" name="X81AC5D2D832C346A"></a></p>

<h5>2.2-4 IsPeriodic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPeriodic</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUltPeriodic</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMaxSeqLFSR</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Period</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PeriodIrreducible</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( method )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PeriodReducible</code>( <var class="Arg">lfsr</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Properties, attributes and methods concerning the periodicity of the output sequence(s), generated by the <var class="Arg">lsfr</var>.</p>

<p>Properties:</p>


<ul>
<li><p><code class="code">IsPeriodic</code>: true if constant term of <code class="code">CharPoly</code> != 0 (8.11 lidl, niederreiter)</p>

</li>
<li><p><code class="code">IsUltPeriodic</code>: true if <code class="code">IsLFSR</code> is true (8.7 lidl, niederreiter)</p>

</li>
<li><p><code class="code">IsMaxSeqLFSR</code>: true if <code class="code">CharPoly</code> is primitive (ref???)</p>

</li>
</ul>
<p>Attributes:</p>


<ul>
<li><p><code class="code">Period</code>: holds the period of the UNKNOWNEntity(LFSR)</p>

</li>
</ul>
<p>Methods to compute the period:</p>


<ul>
<li><p><code class="code">PeriodIrreducible</code>:</p>

</li>
<li><p><code class="code">PeriodReducible</code>:</p>

</li>
</ul>
<p><a id="X797E9B3381339AB2" name="X797E9B3381339AB2"></a></p>

<h4>2.3 <span class="Heading">NLFSR specific funcionality</span></h4>

<p><a id="X824D14CF818525B2" name="X824D14CF818525B2"></a></p>

<h5>2.3-1 ChooseField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ChooseField</code>( <var class="Arg">F</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Workaround for the <code class="code">NLFSR</code> object definition: we need to fix the chosen underlying finite field and prepare indeterminates in the chosen field. The indeterminates will be used for the multivariable polynomial, which will define the <code class="code">NLFSR</code> feedback. Current threshold is set by global <code class="code">MaxNLFSRLen</code> = 100.</p>

<p><a id="X7DDE3CAC7A9D2A55" name="X7DDE3CAC7A9D2A55"></a></p>

<h5>2.3-2 NLFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NLFSR</code>( <var class="Arg">K</var>, <var class="Arg">clist</var>, <var class="Arg">mlist</var>, <var class="Arg">len</var>[, <var class="Arg">tap</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NLFSR</code>( <var class="Arg">K</var>, <var class="Arg">fieldpol</var>, <var class="Arg">clist</var>, <var class="Arg">mlist</var>, <var class="Arg">len</var>[, <var class="Arg">tap</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An empty <code class="code">NLFSR</code> with components <code class="code">init</code>, <code class="code">state</code> and <code class="code">numsteps</code></p>

<p>Different ways to create an <code class="code">NLFSR</code> oblject, main difference is in creation of the underlying finite field.</p>

<p>NOTE: before creating the <code class="code">NLFSR</code>, we must always create the indeterminates to be used for the feedback using <code class="code">ChooseField</code> function call!!! please see example below</p>

<p>Inputs:</p>


<ul>
<li><p><var class="Arg">F</var> - the underlying finite field (either an extension field or a prime field)</p>

</li>
<li><p><var class="Arg">fieldpol</var> - defifning polynomial of the extension field (must be irreducible)</p>

</li>
<li><p><var class="Arg">clist</var> - list of coefficients for the monomials in <var class="Arg">mlist</var></p>

</li>
<li><p><var class="Arg">mlist</var> - list of monomials</p>

</li>
<li><p><var class="Arg">len</var> - length of <code class="code">NLFSR</code></p>

</li>
<li><p><var class="Arg">tap</var> - optional parameter: the output tap (must be a positive integer or a list of positive integers) and will be changed to the default S_0 if the specified integer is out of <code class="code">NLFSR</code>range.</p>

</li>
</ul>
<p>NOTE: <var class="Arg">clist</var> and <var class="Arg">mlist</var> must be of same length, all elements in <var class="Arg">clist</var> must belong to the underlying field. Monomials in <var class="Arg">mlist</var> must not include any indeterminates that are out of range specified by <var class="Arg">len</var>: stages of <code class="code">NLFSR</code> are represented by indeterminants and the feedback is not allowed to use a stage that doesnt exist. A second constraint on <var class="Arg">mlist</var> requires that it must contain at least one monomial of degree <span class="SimpleMath">&gt;</span> 1, otherwise we must create an <code class="code">LFSR</code>.</p>

<p>Compoents:</p>


<ul>
<li><p><code class="code">init</code> - <var class="Arg">FFE</var> vector of length n=deg(charpol), storing the initial state of the <code class="code">NLFSR</code>, with indeces from n-1, ..., 0</p>

</li>
<li><p><code class="code">state</code> - <var class="Arg">FFE</var> vector of length n=deg(charpol), storing the current state of the <code class="code">NLFSR</code>, with indices from n-1, ..., 0</p>

</li>
<li><p><code class="code">numsteps</code> - the number of steps performed thus far (initialized to -1 when created, set to 0 when loaded using <code class="func">LoadFSR</code> (<a href="chap2.html#X7F800DCF810E2532"><span class="RefLink">2.1-5</span></a>) and incremented by 1 with each step (using <code class="func">StepFSR</code> (<a href="chap2.html#X82A7CA487ECAEFD5"><span class="RefLink">2.1-6</span></a>)))</p>

</li>
</ul>
<p>Attributes <code class="func">FieldPoly</code> (<a href="chap2.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>), <code class="func">UnderlyingFied</code> (<span class="RefLink">???</span>), <code class="code">MultivarPoly</code>, <code class="func">FeedbackVec</code> (<a href="chap2.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>), <code class="func">IndetList</code> (<a href="chap2.html#X7C6FCBDC82C3734E"><span class="RefLink">2.3-4</span></a>), <code class="func">Length</code> (<a href="chap2.html#X780769238600AFD1"><span class="RefLink">2.1-3</span></a>) and <code class="func">OutputTap</code> (<a href="chap2.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>) and the property <code class="code">IsNonLinearFeedback</code> are set during the construction of an <code class="code">NLFSR</code>.</p>

<p>If there is something wrong with the arguments (e.g. attempting to create an extension field using a reducible poynomial), an error message appears and the function returns <code class="code">fail</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> F := GF(2);;  clist := [One(F), One(F)];; mlist := [x_0*x_1, x_2];;</span>
Error, Variable: 'x_0' must have a value
not in any function at line 2 of *stdin*
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := NLFSR(F, clist, mlist, 3);</span>
Error, Variable: 'mlist' must have a value
not in any function at line 3 of *stdin*
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChooseField(F);</span>
You can now create an NLFSR with up to 100 stages
with up to  100 nonzero terms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mlist := [x_0*x_1, x_2];;                                           </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := NLFSR(F, clist, mlist, 3);</span>
&lt; empty NLFSR of length 3,
 given by MultivarPoly = x_0*x_1+x_2&gt; 

</pre></div>

<p><a id="X7E493B9784FCFF58" name="X7E493B9784FCFF58"></a></p>

<h5>2.3-3 IsNonLinearFeedback</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNonLinearFeedback</code>( <var class="Arg">nlfsr</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNLFSR</code>( <var class="Arg">nlfsr</var> )</td><td class="tdright">( filter )</td></tr></table></div>
<p>For the multivariate polynomial given by <var class="Arg">clist</var> and <var class="Arg">mlist</var>, DegreeOfPolynomial greter than 1 sets <code class="code">IsNonLinearFeedback</code> to <em>true</em>. otherwise it prints out a warning that you need to use the <code class="code">LFSR</code> constructor instead.</p>

<p>Filter <code class="code">IsNLFSR</code> is defined as and-filter of <code class="code">IsFSR</code> and <code class="code">IsNonLinearFeedback</code>.</p>

<p>NOTE: at the same time <code class="code">IsLinearFeedback</code> is set to <em>false</em> (for coding purposes).</p>

<p><a id="X7C6FCBDC82C3734E" name="X7C6FCBDC82C3734E"></a></p>

<h5>2.3-4 MultivarPoly</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MultivarPoly</code>( <var class="Arg">nlfsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndetList</code>( <var class="Arg">nlfsr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><code class="code">MultivarPoly</code> holds the multivariate function defining the feedback of the <code class="code">NLFSR</code>. <code class="code">IndetList</code> holds all the indeterminates that are present in <code class="code">MultivarPoly</code> and <code class="code">FeedbackVec</code> holds only the nonzero coefficients (as opposed to the <code class="code">LFSR</code>, where this field holds coefficients for all stages of the <code class="code">FSR</code>). The feedback element is computed from <code class="code">MultivarPoly</code>, <code class="code">IndetList</code> and <code class="code">state</code>, and not from <code class="code">FeedbackVec</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MultivarPoly(test); IndetList(test);</span>
x_0*x_1+x_2
[ 0, 1, 2 ]

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
